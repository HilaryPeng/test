<!DOCTYPE html>
<html>
<meta charset="utf-8">
</html>
<body>

<script>
/*
Proxy
	1.概述
	Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种‘元编程’，即对编程语言
	进行编译
	Proxy可以理解为在目标对象之间架设一层“拦截”，外界对该对象的访问，都必须通过这层拦截，因此提供了一层机制。可以对外界的访问进行过滤和改写。
	ES6提供了Proxy构造函数，用来生成Proxy实例。
	var proxy= new Proxy(target,handler);
	Proxy对象的所有用法，都是上面的形式，不同的只是handler的用法。target是表示要拦截的目标对象。handler参数是一个对象，用来定制拦截行为。
	例子：
	var proxy=new Proxy({},{
		get:function(target,property){
			return 35
		}
	})
proxy.time //35
proxy.name //35
proxy.title //35
由于设置了拦截所以每次的访问过后返回的都是35
get方法的两个参数分别是目标对象和所要访问的属性。

如果handler没有设置拦截，就直接访问原对象。

	方法：
 （1）get(target, propKey, receiver)
 （2）set(target, propKey, value, receiver)
 （3）has(target, propKey)
 （4）deleteProperty(target, propKey)
 （5）ownKeys(target)
 （6）getOwnPropertyDescriptor(target, propKey)
 （7）defineProperty(target, propKey, propDesc)
 （8）preventExtensions(target)
 （9）getPrototypeOf(target)
 （10）isExtensible(target)
 （11）setPrototypeOf(target, proto)
 （12）apply(target, object, args)
 （13）construct(target, args)
Proxy实例的方法
 1.set的用法

 var person = {
 name: "张三"
 };

 var proxy = new Proxy(person, {
 get: function(target, property) {
 if (property in target) {
 return target[property];
 } else {
 throw new ReferenceError("Property \"" + property + "\" does not exist.");
 }
 }
 });
2.set()
	假设Person对象有一个age属性，该属性要求是一个不大于200的整数，那么可以使用Proxy保证age的属性值的集合。
	let validetor={
		set:function(obj,prop,value){
			if(prop=='age'){
				if(!Number.isInteger(value)){
				 throw new TypeError('The age is not an integer');
				}else{
					if(value>200){
 				throw new RangeError('The age seems invalid');
						}
				}
 			obj[prop] = value;
			}
		}
	}
 let person = new Proxy({}, validator);
3.apply()
 	apply方法拦截函数的调用，call和apply操作。
 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
4.has()
 has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。


	*/

//es5中没有这个方法。 现在的浏览器还不识别。

</script>
</body>