<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>

	<body>
	</body>
	<script>
		/*
		 * 3.const 命令
		 const声明一个只读的变量，一旦声明，其值不可以改变；
		 和let的用法一样，同样存在暂时性死区。只能在声明的位置后面使用!同时也不可重复。const声明过的 在同一块级作用域内 也不可用let进行声明
		const t=5;
		声明值可以不变，但是声明了一个对象，对象的属性是可变的，只是地址不变！所以我们可以尽情地玩弄他，给她添加新属性
		const foo={};
		foo.name='黄致鹏';
		console.log(foo) {name:'黄致鹏'}
		
		const a=[];
		a.push('Hello');
		a.length=0;
		//console.log(a) //[]
		
		ES6声明变量的方法，一共有六种，分别是 var function const let import class
		
		4.顶层对象的属性
		顶层对象，在浏览器中就是window属性，在NODE中是global对象，ES5中，顶层对象与全局变量是等价的。
		顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。带的问题是什么呢？
			1.无法在编译时知道变量为声明的错误。只有在运行时才知道。
			2.可能在不知道的情况下，创建了全局变量。
			3.顶层对象时可以到处读写的。不利于模块化编程。
			4.window是有实体含义的，指的时浏览器的窗口，顶层对象是一个有实体含义的对象，也是不合适的。
		ES6的改变：
			一方面为了保持兼容行，var 命令和function命令声明的全局变量。依旧是顶层对象的属性，另一方面规定。let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。全局变量将与顶层对象的属性脱钩。
			let b=1;
			wiondow.b //undefined
			
		5.global 对象
		 ES5的顶层对象，有问题，因为在各种实现里面是不统一的。
		 浏览器里面，顶层对象是window，当node和web worker没有window
		 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
		Node 里面，顶层对象是global，但其他环境都不支持。
		感觉是等待标准不断的升级从而来获取统一的全局变量！
		
		同一段代码为了能够在各种环境，都能取到顶层对象，现在一般都是使用this变量，但是有局限性。
		全局环境中，this会返回顶层对象，但是NODE模块和ES6 this返回的是当前模块。
		函数里的this，如果不是作为对象的方法运行，单纯作为函数运行，那么this会指向顶层对象，严格模式下，this会返回undefined;
		不管严格模式还是普通模式，new Function('return this')(),总是会返回全局对象。但是，如果浏览器用了CSP（内容安全政策），那么eval，new Function都无法用。所以基本没有方法可以在任何情况下都取到顶层对象。
		方法1：
		var getGlobal = function () {
		  if (typeof self !== 'undefined') { return self; }
		  if (typeof window !== 'undefined') { return window; }
		  if (typeof global !== 'undefined') { return global; }
		  throw new Error('unable to locate global object');
		};
		
		新的提案，全部的环境，顶层对象global。
		*/
		
		

	</script>

</html>