// var a = {n: 1};
// var b = a;
// a.x = a = {n: 2}; // 赋值操作是从右到左 所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x  => b.x = {n:2}
// // a {n: 2} //b {n:1, x:{n: 2}}; 


// 栈 堆 池（ 常量。） 闭包的变量存放在堆内存中。 这也就是说函数之后为什么闭包还能引用到函数内部的变量。
//垃圾回收算法 引用计数 标记清除
//引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。
//引用计数有一个致命的问题，那就是循环引用
//如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。
//不再使用的对象”定义为“无法到达的对象” 即从根部（在JS中就是全局对象）
//出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收

/**
 * 
 * 无法触及的对象包含了没有引用的对象这个概念，但反之未必成立
 * 所以上面的例子就可以正确被垃圾回收处理了。
 * 所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：
 * email.message = document.createElement(“div”);
   displayList.appendChild(email.message);
   // 稍后从displayList中清除DOM元素
   displayList.removeAllChildren();
   上面代码中，div元素已经从DOM树中清除，但是该div元素还绑定在email对象中，所以如果email对象存在，那么该div元素就会一直保存在内存中。


 * 从内存来看 null 和 undefined 本质的区别是什么？ 
 给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null
 ,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。
 给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值



   ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？  
   const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动.至于它指向的数据结构是不是可变的，就完全不能控制了
   const foo = {}; 
    foo = {}; // TypeError: "foo" is read-only
    foo.prop = 123;
    foo.prop // 123
    哪些情况下容易产生内存泄漏？
    1.DOM/BOM 对象泄漏
    2.script 中存在对DOM/BOM 对象的引用导致
    3.Javascript 对象泄漏
    4.通常由闭包导致，比如事件处理回调，导致DOM对象和脚本中对象双向引用，这个时常见的泄漏原因
    定时器setTimeout setInterval
    mounted/created 钩子中使用了$on，需要在beforeDestroy 中做对应解绑($off)处理
    给DOM对象添加的属性是一个对象的引用
 * 
 */
